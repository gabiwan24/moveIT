<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live ASCII Text — Optimized</title>
  <style>
    :root{--bg:#0f0f10;--fg:#e5e7eb;--panel:#151517;--panelBorder:#2a2a2e}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:monospace;overflow:hidden;user-select:none}
    .ghost-input{position:fixed;inset:0;opacity:0;cursor:default}
    canvas{position:fixed;inset:0;display:block}
    .legend{position:fixed;left:12px;bottom:10px;font-size:12px;opacity:.7;color:#9ca3af;pointer-events:none}
    .controls{position:fixed;right:12px;top:12px;z-index:20;display:flex;gap:.6rem;align-items:center;background:var(--panel);border:1px solid var(--panelBorder);border-radius:6px;padding:6px 10px;font-size:12px}
  </style>
</head>
<body>
  <input id="hidden" class="ghost-input" autocomplete="off" spellcheck="false" />
  
  <canvas id="work" style="display:none"></canvas> <canvas id="anim"></canvas> <div class="legend">Type to spawn particles. Mouse interaction enabled.</div>
  <div class="controls">
    <label>Friction</label>
    <input id="fSlider" type="range" min="0.90" max="0.99" step="0.001" value="0.960" />
  </div>

  <script>
    // --- KONFIGURATION ---
    const CONFIG = {
      friction: 0.96,
      cellSize: 8,      // Größe der ASCII Zellen
      maxLen: 20,       // Max Input Länge
      fontSizeBase: 0.6 // Verhältnis Screen/Font
    };

    // Zeichenvorrat sortiert nach Dichte (ungefähr)
    const CHARSET = " .'`^:,;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$";

    // --- DOM ELEMENTE ---
    const els = {
      hidden: document.getElementById('hidden'),
      anim: document.getElementById('anim'),
      work: document.getElementById('work'),
      slider: document.getElementById('fSlider')
    };
    
    const ctxs = {
      anim: els.anim.getContext('2d', { alpha: false }), // Alpha false für Performance
      work: els.work.getContext('2d', { willReadFrequently: true }) // Hint für Browser
    };

    // --- STATE ---
    let particles = [];
    let charCache = {}; // Map: Char -> OffscreenCanvas
    let isDragging = false;
    let dragIdx = -1;
    const mouse = { x: 0, y: 0, r: 50, active: false };
    
    // Zufallsgenerator (Xorshift)
    const seedRandom = (s) => () => {
      s ^= s << 13; s ^= s >>> 17; s ^= s << 5;
      return ((s >>> 0) / 4294967296);
    };

    // --- 1. PRE-RENDERING / CACHING (Performance Boost) ---
    function updateCharCache(size) {
      charCache = {};
      const font = `${size}px monospace`;
      
      // Wir erstellen für jedes Zeichen im Charset ein kleines Bild
      for (let char of CHARSET) {
        const c = document.createElement('canvas');
        c.width = size;
        c.height = size;
        const x = c.getContext('2d');
        x.font = font;
        x.textAlign = 'center';
        x.textBaseline = 'middle';
        
        // Farbe ist hier weiß, wir färben es später nicht um für max Speed
        // (Für farbige Partikel müsste man komplexere Shader oder CompositeOps nutzen)
        x.fillStyle = '#e5e7eb'; 
        x.fillText(char, size/2, size/2);
        charCache[char] = c;
      }
    }

    // --- 2. TEXT ANALYSE ---
    function renderTextAndScan() {
      const W = window.innerWidth;
      const H = window.innerHeight;
      
      // Resizing der Canvases
      if (els.anim.width !== W || els.anim.height !== H) {
        els.anim.width = els.work.width = W;
        els.anim.height = els.work.height = H;
        // Cache neu bauen wenn sich Größe ändert
        CONFIG.cellSize = Math.max(6, Math.floor(W / 120)); 
        updateCharCache(CONFIG.cellSize);
      }

      const ctx = ctxs.work;
      const text = els.hidden.value.toUpperCase().slice(0, CONFIG.maxLen);

      // Hintergrund schwarz
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, W, H);

      if (!text) return [];

      // Text rendern (Groß und fett für Analyse)
      const baseSize = Math.min(W, H) * CONFIG.fontSizeBase;
      ctx.font = `900 ${baseSize}px Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Skalierung berechnen damit Text passt
      const textWidth = ctx.measureText(text).width;
      const scale = Math.min(1, (W * 0.9) / textWidth);
      ctx.setTransform(scale, 0, 0, scale, W/2, H/2);
      
      // Text Gradient
      const gradient = ctx.createLinearGradient(-W/2, -H/2, W/2, H/2);
      gradient.addColorStop(0, '#555');
      gradient.addColorStop(0.5, '#fff');
      gradient.addColorStop(1, '#555');
      ctx.fillStyle = gradient;
      ctx.fillText(text, 0, 0);
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset

      // Pixel Daten holen
      const idata = ctx.getImageData(0, 0, W, H).data;
      const newParticles = [];
      const cs = CONFIG.cellSize;
      
      // OPTIMIERUNG: Schrittweite = CellSize (statt jedes Pixel)
      const cols = Math.floor(W / cs);
      const rows = Math.floor(H / cs);

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          // Sampling in der Mitte der Zelle
          const px = Math.floor((x + 0.5) * cs);
          const py = Math.floor((y + 0.5) * cs);
          const idx = (py * W + px) * 4;

          const r = idata[idx];
          // Nur helle Pixel beachten
          if (r > 20) {
            // Mapping Helligkeit -> Zeichenindex
            const cIdx = Math.floor((r / 255) * (CHARSET.length - 1));
            const char = CHARSET[cIdx];
            
            // Einfache Kollisionsvermeidung durch Grid-Position
            newParticles.push({
              x: px,
              y: py,
              vx: 0,
              vy: 0,
              char: char,
              // ID für Konsistenz (optional)
              id: x + y * cols 
            });
          }
        }
      }
      return newParticles;
    }

    // --- 3. PHYSIK & RENDER LOOP ---
    function loop() {
      const ctx = ctxs.anim;
      const W = els.anim.width;
      const H = els.anim.height;
      const cs = CONFIG.cellSize;

      // Clear (schnellste Methode ohne Transparenz)
      ctx.fillStyle = '#0f0f10';
      ctx.fillRect(0, 0, W, H);

      // Mouse Physics Pre-Calc
      const mx = mouse.x;
      const my = mouse.y;
      const mActive = mouse.active;
      const mRadSq = mouse.r * mouse.r;

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];

        // 1. Interaktion
        if (isDragging && i === dragIdx) {
          // Dragging: Harte Feder zur Maus
          p.vx += (mx - p.x) * 0.15;
          p.vy += (my - p.y) * 0.15;
        } else if (mActive) {
          // Pushen
          const dx = p.x - mx;
          const dy = p.y - my;
          const distSq = dx*dx + dy*dy;
          
          if (distSq < mRadSq && distSq > 0) {
            const dist = Math.sqrt(distSq);
            const force = (mouse.r - dist) / mouse.r; // 0..1
            const push = force * 25; // Stärke
            p.vx += (dx / dist) * push;
            p.vy += (dy / dist) * push;
          }
        }

        // 2. Integration & Reibung
        p.vx *= CONFIG.friction;
        p.vy *= CONFIG.friction;
        p.x += p.vx;
        p.y += p.vy;

        // 3. Wände (Bounce)
        if (p.x < 0) { p.x = 0; p.vx *= -0.5; }
        else if (p.x > W - cs) { p.x = W - cs; p.vx *= -0.5; }
        
        if (p.y < 0) { p.y = 0; p.vy *= -0.5; }
        else if (p.y > H - cs) { p.y = H - cs; p.vy *= -0.5; }

        // 4. Rendering (Optimiert mit Cache)
        const sprite = charCache[p.char];
        if (sprite) {
          // Math.floor verhindert Subpixel-Rendering (schärfer + schneller)
          ctx.drawImage(sprite, Math.floor(p.x), Math.floor(p.y));
        }
      }

      requestAnimationFrame(loop);
    }

    // --- EVENTS ---
    function rebuild() {
      particles = renderTextAndScan();
    }

    els.hidden.addEventListener('input', rebuild);
    els.slider.addEventListener('input', e => CONFIG.friction = parseFloat(e.target.value));
    
    // Maus
    window.addEventListener('pointermove', e => {
      mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true;
    });
    window.addEventListener('pointerleave', () => { mouse.active = false; isDragging = false; });
    window.addEventListener('pointerup', () => { isDragging = false; dragIdx = -1; });
    
    window.addEventListener('pointerdown', e => {
      mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true;
      // Nächstes Teil finden
      let bestDist = 1000;
      let bestIdx = -1;
      for(let i=0; i<particles.length; i++){
        const dx = particles[i].x - mouse.x;
        const dy = particles[i].y - mouse.y;
        const d = dx*dx + dy*dy;
        if(d < bestDist && d < 900) { bestDist = d; bestIdx = i; }
      }
      if(bestIdx !== -1) {
        dragIdx = bestIdx;
        isDragging = true;
      }
    });

    window.addEventListener('resize', () => {
      renderTextAndScan(); // Re-init bei Resize
      rebuild();
    });

    // Init
    window.addEventListener('load', () => {
      els.hidden.focus();
      els.hidden.value = "ASCII"; // Start Text
      rebuild();
      loop();
    });
    
    // Fokus behalten
    window.addEventListener('click', () => els.hidden.focus());

  </script>
</body>
</html>
